{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/StakeChain_States.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.26;\n/// @notice This contract controls the states of the StateChain contract\n/// @custom:contact franzquarshie@gmail.com\n\nerror StakeChain__Unauthorized();\n\n/**\n * @title StakeChain Extended\n * @custom:security-contact franzquarshie@gmail.com\n */\ncontract StakeChain_States {\n\t/// @notice Base percentage used for calculations, representing 100%\n\tuint256 public constant PERCENTAGE = 100 ether;\n\taddress public constant OWNER = 0xd54d09a4154F47ba8a82e6BDa548bcbc348a83E2;\n\n\taddress public SUSTAINABILITY_FEE_COLLECTOR =\n\t\t0xFFD0a549e6982FB553302274d342dD6673b0deEE;\n\n\t/// @notice Fee percentage deducted from each transaction\n\tuint256 public PLATFORM_FEE = 1 ether;\n\t/// @notice Settle reward percentage for the user who settles the bets\n\tuint256 public SETTLE_REWARD = 0.01 ether;\n\t/// @notice Percentage that goes to environment sustainability\n\tuint256 public SUSTAINABILITY_FEE = 0.5 ether;\n\n\t/// @notice Platform Account\n\taddress public constant PLATFORM_WALLET =\n\t\t0xd54d09a4154F47ba8a82e6BDa548bcbc348a83E2;\n\n\t/**\n\t * @dev Administrative\n\t * @param _amount New platform fee\n\t */\n\tfunction UpdatePlatformFee(uint256 _amount) public _isOwner {\n\t\tPLATFORM_FEE = _amount;\n\t}\n\n\t/**\n\t * @dev Administrative\n\t * @param _amount New Sustainability fee\n\t */\n\tfunction UpdateSustainabilityFee(uint256 _amount) public _isOwner {\n\t\tSUSTAINABILITY_FEE = _amount;\n\t}\n\n\t/**\n\t * @dev Administrative\n\t * @param newCollector Update sustainability fee collector\n\t */\n\tfunction UpdateSustainabilityFeeCollector(\n\t\taddress newCollector\n\t) public _isOwner {\n\t\tSUSTAINABILITY_FEE_COLLECTOR = newCollector;\n\t}\n\n\tmodifier _isOwner() {\n\t\tif (msg.sender != OWNER) {\n\t\t\trevert StakeChain__Unauthorized();\n\t\t}\n\t\t_;\n\t}\n}\n"
    },
    "contracts/StakeChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n/// @notice This contract allows users to place bets\n/// @custom:contact franzquarshie@gmail.com\n\nimport { StakeChain_States } from \"./StakeChain_States.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nerror StakeChain__OnlyOwner();\nerror StakeChain__BetNotOpen();\nerror StakeChain__BetStillOpen();\nerror StakeChain__BetNotSettled();\nerror StakeChain__InvalidOutcome();\nerror StakeChain__BetAmountZero();\nerror StakeChain__BetAlreadyPlaced();\nerror StakeChain__BetsAlreadySettled();\nerror StakeChain__NoShareAvailable();\n\n/**\n * @title StakeChain\n * @custom:security-contact franzquarshie@gmail.com\n */\ncontract StakeChain is StakeChain_States, ReentrancyGuard {\n\tstruct Bet {\n\t\tuint256 amount;\n\t\tuint256 outcome;\n\t\tbool claimed;\n\t}\n\n\tstruct BetEvent {\n\t\tstring title;\n\t\tstring description;\n\t\tstring[] options;\n\t\tuint256 totalPool;\n\t\tuint256 winnerPool;\n\t\tuint256 loserPool;\n\t\tuint256 outcome;\n\t\tbool betOpen;\n\t\tbool betSettled;\n\t\tmapping(address => Bet) bets;\n\t\tmapping(address => uint256) shares;\n\t\taddress[] players;\n\t}\n\n\tuint256 public betEventCount;\n\n\tmapping(uint256 => BetEvent) public betEvents;\n\n\tevent BetPlaced(\n\t\tuint256 indexed betEventId,\n\t\taddress indexed player,\n\t\tuint256 amount,\n\t\tuint256 outcome\n\t);\n\tevent BetSettled(uint256 indexed betEventId, uint256 outcome);\n\tevent ShareClaimed(\n\t\tuint256 indexed betEventId,\n\t\taddress indexed player,\n\t\tuint256 amount\n\t);\n\tevent SCHAINDistributed(address indexed player, uint256 amount);\n\tevent BetEventCreated(\n\t\tuint256 indexed betEventId,\n\t\tstring title,\n\t\tstring description,\n\t\tstring[] options\n\t);\n\n\tmodifier onlyOwner() {\n\t\tif (msg.sender != OWNER) revert StakeChain__OnlyOwner();\n\t\t_;\n\t}\n\n\tmodifier betIsOpen(uint256 _betEventId) {\n\t\tif (!betEvents[_betEventId].betOpen) revert StakeChain__BetNotOpen();\n\t\t_;\n\t}\n\n\tmodifier betIsClosed(uint256 _betEventId) {\n\t\tif (betEvents[_betEventId].betOpen) revert StakeChain__BetStillOpen();\n\t\t_;\n\t}\n\n\tmodifier betIsSettled(uint256 _betEventId) {\n\t\tif (!betEvents[_betEventId].betSettled)\n\t\t\trevert StakeChain__BetNotSettled();\n\t\t_;\n\t}\n\n\t// Create a new betting event with title, description, and options\n\tfunction createBetEvent(\n\t\tstring memory _title,\n\t\tstring memory _description,\n\t\tstring[] memory _options\n\t) external onlyOwner {\n\t\tbetEventCount++;\n\t\tBetEvent storage newBetEvent = betEvents[betEventCount];\n\t\tnewBetEvent.title = _title;\n\t\tnewBetEvent.description = _description;\n\t\tnewBetEvent.options = _options;\n\t\tnewBetEvent.betOpen = true;\n\n\t\temit BetEventCreated(betEventCount, _title, _description, _options);\n\t}\n\n\t// Players can place their bets\n\tfunction placeBet(\n\t\tuint256 _betEventId,\n\t\tuint256 _outcome\n\t) external payable betIsOpen(_betEventId) {\n\t\tif (msg.value == 0) revert StakeChain__BetAmountZero();\n\t\tif (betEvents[_betEventId].bets[msg.sender].claimed)\n\t\t\trevert StakeChain__BetAlreadyPlaced();\n\n\t\tBetEvent storage _betEvent = betEvents[_betEventId];\n\n\t\t_betEvent.bets[msg.sender] = Bet(msg.value, _outcome, false);\n\t\t_betEvent.players.push(msg.sender);\n\t\t_betEvent.totalPool += msg.value;\n\n\t\temit BetPlaced(_betEventId, msg.sender, msg.value, _outcome);\n\t}\n\n\t// Close betting and set the outcome for a specific  bet event\n\tfunction closeBetting(\n\t\tuint256 _betEventId,\n\t\tuint256 _outcome\n\t) external onlyOwner betIsOpen(_betEventId) {\n\t\tif (_outcome == 0 || _outcome > betEvents[_betEventId].options.length)\n\t\t\trevert StakeChain__InvalidOutcome();\n\t\tbetEvents[_betEventId].outcome = _outcome;\n\t\tbetEvents[_betEventId].betOpen = false;\n\t\temit BetSettled(_betEventId, _outcome);\n\t}\n\n\t// Settle the bets and distribute winnings to the winners\n\tfunction settleBets(\n\t\tuint256 _betEventId\n\t) external nonReentrant betIsClosed(_betEventId) {\n\t\tif (betEvents[_betEventId].betSettled)\n\t\t\trevert StakeChain__BetsAlreadySettled();\n\n\t\tBetEvent storage _betEvent = betEvents[_betEventId];\n\n\t\t// Calculate the total pools for winners and losers\n\t\tfor (uint256 i = 0; i < _betEvent.players.length; i++) {\n\t\t\taddress player = _betEvent.players[i];\n\t\t\tif (_betEvent.bets[player].outcome == _betEvent.outcome) {\n\t\t\t\t_betEvent.winnerPool += _betEvent.bets[player].amount;\n\t\t\t} else {\n\t\t\t\t_betEvent.loserPool += _betEvent.bets[player].amount;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate and deduct platform fees\n\t\tuint256 platformFee = (_betEvent.totalPool * PLATFORM_FEE) / PERCENTAGE;\n\t\tuint256 sustainabilityFee = (_betEvent.totalPool * SUSTAINABILITY_FEE) /\n\t\t\tPERCENTAGE;\n\t\tuint256 settlerReward = (_betEvent.totalPool * SETTLE_REWARD) /\n\t\t\tPERCENTAGE;\n\n\t\t// Calculate the remaining pool after fees\n\t\tuint256 remainingPool = _betEvent.totalPool -\n\t\t\tplatformFee -\n\t\t\tsustainabilityFee -\n\t\t\tsettlerReward;\n\n\t\t// Send platform fee to PLATFORM_WALLET\n\t\tpayable(PLATFORM_WALLET).transfer(platformFee);\n\n\t\t// Send sustainability fee to SUSTAINABILITY_FEE_COLLECTOR\n\t\tpayable(SUSTAINABILITY_FEE_COLLECTOR).transfer(sustainabilityFee);\n\n\t\t// Distribute remaining pool to winners\n\t\tfor (uint256 i = 0; i < _betEvent.players.length; i++) {\n\t\t\taddress player = _betEvent.players[i];\n\t\t\tif (_betEvent.bets[player].outcome == _betEvent.outcome) {\n\t\t\t\tuint256 winnings = (_betEvent.bets[player].amount *\n\t\t\t\t\tremainingPool) / _betEvent.winnerPool;\n\t\t\t\tpayable(player).transfer(\n\t\t\t\t\twinnings + _betEvent.bets[player].amount\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Transfer settle reward to the caller\n\t\tpayable(msg.sender).transfer(settlerReward);\n\n\t\t_betEvent.betSettled = true;\n\n\t\temit BetSettled(_betEventId, _betEvent.outcome);\n\t}\n\n\t// In case there are any leftover funds, the owner can withdraw them\n\tfunction withdrawFunds(\n\t\tuint256 _betEventId\n\t) external onlyOwner betIsSettled(_betEventId) {\n\t\tpayable(OWNER).transfer(address(this).balance);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}